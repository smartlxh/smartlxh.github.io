<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="八阿哥">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="八阿哥">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="八阿哥">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/"/>





  <title>八阿哥</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">八阿哥</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">八阿哥</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/22/java序列化多个对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="八阿哥">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/22/java序列化多个对象/" itemprop="url">java序列化多个对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-10-22T19:41:05+08:00">
                2016-10-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://ppmtv6c75.bkt.clouddn.com/2019/04/08/daf9d119cd09e5689bcac383c060c92f.jpeg" alt="pexels-photo-2040626.jpeg"></p>
<p>今天写程序的时候，需要将多个对象序列化到文件中去，但是写的时没有问题，当读的时候就会报错 invalid type code: AC。原因是ObjectOutputStream 会在将对象写到文件之前，先添加一个header到文件中去，当有多个对象时，读到，这个header就会报错，解决的方法有两种</p>
<ol>
<li><p>继承ObjectOututStream，复写writeStreamHeader()方法<br>然后在写程序的时候，要判断文件是否存在，若不存，则使用ObjectOutputstream类进行读写，若已经存在，则无需在添加header，所以采用ObjectOutputStream的子类</p>
<pre><code>public class NewObjectOutputStream extends ObjectOurputStream{
    public void writeStreamHeader(){
    //制空
}
</code></pre></li>
<li><p>在写文件是，使用FileChannel类截断header的4个字节</p>
<pre><code>public boolean writeToFile(Items items){
    try{
        File file = new File(&quot;./data.ser&quot;);
        if(file.exists()){
        boolean isexist=true;
        FileOutputStream fo=new     FileOutputStream(file,true);
        ObjectOutputStream oos = new ObjectOutputStream(fo);
    long pos=0;
        if(isexist){
            System.out.println(fo.getChannel().position());
        pos=fo.getChannel().position()-4;

            System.out.println(pos+&quot; &quot;+fo.getChannel().size());
        fo.getChannel().truncate(pos);

    }
    oos.writeObject(items);//进行序列化
    return true;
}else{//文件不存在
    file.createNewFile();
    FileOutputStream fo=new FileOutputStream(file);
    ObjectOutputStream oos = new ObjectOutputStream(fo);
    oos.writeObject(items);//进行序列
    return true;
}
</code></pre></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/21/Flume学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="八阿哥">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/21/Flume学习笔记/" itemprop="url">Flume学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-10-21T20:50:57+08:00">
                2016-10-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://ppmtv6c75.bkt.clouddn.com/2019/04/08/645043a34b113eaa94776a5e87b0ff5b.jpeg" alt="pexels-photo-1624438.jpeg"></p>
<p>最近要写一个日志手机系统，打算采用flume+kafka+storm的技术栈<br>所以先学习了一下Flume</p>
<p>Flume是apache下的一款开源的日志收集系统。它支持分布式，和高吞吐率。但是Flume不仅仅可以用来收集日志，它也常被用来传输消息，比如媒体流，email消息等等。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>| Agent 使用JVM运行Flume，每台机器一个agnet |<br>| Source | 从服务器上监测和收集日志信息 |<br>| Channel | 连接source和links，并可以保存event |</p>
<p>|Sink|将Channel中的数据送到其他地方<br>|Events|可以是日志记录 avro对象</p>
<h2 id="Flume基本模型"><a href="#Flume基本模型" class="headerlink" title="Flume基本模型"></a>Flume基本模型</h2><p>Flume以agent为最小的独立运行单位。一个agent就是一个JVM。单agent由Source、Sink和Channel三大组件</p>
<p><img src="http://i1.piimg.com/567571/5a8d60c806eb0151.png" alt=""></p>
<h2 id="Flume配置文件"><a href="#Flume配置文件" class="headerlink" title="Flume配置文件"></a>Flume配置文件</h2><p>首先我们来看一个简单的例子</p>
<pre><code># example.conf: A single-node Flume configuration

# 命名agent的各个组件名
a1.sources = r1
a1.sinks = k1
a1.channels = c1

# 描述和配置各组件属性
a1.sources.r1.type = netcat
a1.sources.r1.bind = localhost
a1.sources.r1.port = 44444


a1.sinks.k1.type = logger


a1.channels.c1.type = memory
a1.channels.c1.capacity = 1000
a1.channels.c1.transactionCapacity = 100

# 将channel，sink和source绑定
a1.sources.r1.channels = c1
a1.sinks.k1.channel = c1
</code></pre><h2 id="Flume常见几种连接方式"><a href="#Flume常见几种连接方式" class="headerlink" title="Flume常见几种连接方式"></a>Flume常见几种连接方式</h2><p> 1.Multi-agent flow</p>
<p> 多个agent的Source和Link依次相连</p>
<p><img src="http://i1.piimg.com/567571/1a371593a12f0eca.png" alt=""></p>
<p>2.Fan out flow</p>
<p>一个Agent中的一个Source可以连接到多个Channel上，然后通过配置selector来屁诶event中的header从而确定将消息发送到具体哪一个Channel<br><img src="http://i1.piimg.com/567571/ec0051f95c377261.png" alt=""></p>
<p>3.An agent multi flow</p>
<p><img src="http://p1.bqimg.com/567571/8b71522ac43d3b16.png" alt=""></p>
<p>4.Consolidation</p>
<p>多个agent运行在各个服务器上收集日志，然后统一传到一个colletor，由这个collector统一处理数据，比如存到HDFS以实现数据持久化。</p>
<p><img src="http://i1.piimg.com/567571/b927f83efc750e49.png" alt=""></p>
<h2 id="关于Agent各个组件中的个数问题"><a href="#关于Agent各个组件中的个数问题" class="headerlink" title="关于Agent各个组件中的个数问题"></a>关于Agent各个组件中的个数问题</h2><p>1.Source:在同一个Agent中，可以有多个source</p>
<p>2.Channel: 在同一个Agent中，可以与多个source相连也可以与多个</p>
<p>3.sinks相连。与多个source相连即有多个消息源。与多个sinks相连时，要配置sinkgroups 这是实现负载均衡的方式<br>比如如下配置，a1位agent名，g1是sinkgroup组名</p>
<pre><code>a1.sinkgroups.g1.processor.type = load_balance
a1.sinkgroups.g1.processor.backoff   = true
a1.sinkgroups.g1.processor.selector  = random
</code></pre><p>sinks:只能与一个Channel相连，也只能将消息发送到一个目的地</p>
<p><a href="https://flume.apache.org/FlumeUserGuide.html" target="_blank" rel="external">Flume官方文档</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/15/docker-compose编排应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="八阿哥">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/15/docker-compose编排应用/" itemprop="url">docker-compose编排应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-10-15T15:44:19+08:00">
                2016-10-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://ppmtv6c75.bkt.clouddn.com/2019/04/08/aa5c6664412017688da4bd37326e6182.jpeg" alt="pexels-photo-1190297.jpeg"></p>
<h3 id="YAML-模板文件"><a href="#YAML-模板文件" class="headerlink" title="YAML 模板文件"></a>YAML 模板文件</h3><p>默认的模板文件是 docker-compose.yml，其中定义的每个服务都必须通过 image 指令指定镜像或 build 指令（需要 Dockerfile）来自动构建。</p>
<p>其它大部分指令都跟 docker run 中的类似。</p>
<p>如果使用 build 指令，在 Dockerfile 中设置的选项(例如：CMD, EXPOSE, VOLUME, ENV 等) 将会自动被获取，无需在 docker-compose.yml 中再次设置。</p>
<p>image</p>
<p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉去这个镜像。</p>
<p>例如：</p>
<pre><code>image: ubuntu
image: orchardup/postgresql
image: a4bc65fd
build
</code></pre><p>指定 Dockerfile 所在文件夹的路径。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像。</p>
<pre><code>build: /path/to/build/dir
command
</code></pre><p>覆盖容器启动后默认执行的命令。</p>
<pre><code>command: bundle exec thin -p 3000
links
</code></pre><p>链接到其它服务中的容器。使用服务名称（同时作为别名）或服务名称：服务别名 （SERVICE:ALIAS） 格式都可以。</p>
<pre><code>links:
- db
- db:database
- redis
</code></pre><p>使用的别名将会自动在服务容器中的 /etc/hosts 里创建。例如：</p>
<pre><code>172.17.2.186  db
172.17.2.186  database
172.17.2.187  redis
</code></pre><p>相应的环境变量也将被创建。</p>
<p>external_links</p>
<p>链接到 docker-compose.yml 外部的容器，甚至 并非 Compose 管理的容器。参数格式跟 links 类似。</p>
<pre><code>external_links:
- redis_1
- project_db_1:mysql
- project_db_1:postgresql
</code></pre><p>ports</p>
<p>暴露端口信息。</p>
<p>使用宿主：容器 （HOST:CONTAINER）格式或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p>
<pre><code>ports:
- &quot;3000&quot;
- &quot;8000:8000&quot;
- &quot;49100:22&quot;
- &quot;127.0.0.1:8001:8001&quot;
</code></pre><p>注：当使用 HOST:CONTAINER 格式来映射端口时，如果你使用的容器端口小于 60 你可能会得到错误得结果，因为 YAML 将会解析 xx:yy 这种数字格式为 60 进制。所以建议采用字符串格式。</p>
<p>expose</p>
<p>暴露端口，但不映射到宿主机，只被连接的服务访问。</p>
<p>仅可以指定内部端口为参数</p>
<pre><code>expose:
- &quot;3000&quot;
- &quot;8000&quot;
volumes
</code></pre><p>卷挂载路径设置。可以设置宿主机路径 （HOST:CONTAINER） 或加上访问模式 （HOST:CONTAINER:ro）。</p>
<pre><code>volumes:
- /var/lib/mysql
- cache/:/tmp/cache
- ~/configs:/etc/configs/:ro
</code></pre><p>volumes_from</p>
<p>从另一个服务或容器挂载它的所有卷。</p>
<pre><code>volumes_from:
- service_name
- container_name
environment
</code></pre><p>设置环境变量。你可以使用数组或字典两种格式。</p>
<p>只给定名称的变量会自动获取它在 Compose 主机上的值，可以用来防止泄露不必要的数据。</p>
<pre><code>environment:
RACK_ENV: development
SESSION_SECRET:

environment:
- RACK_ENV=development
- SESSION_SECRET
env_file
</code></pre><p>从文件中获取环境变量，可以为单独的文件路径或列表。</p>
<p>如果通过 docker-compose -f FILE 指定了模板文件，则 env_file 中路径会基于模板文件路径。</p>
<p>如果有变量名称与 environment 指令冲突，则以后者为准。</p>
<p>env_file: .env</p>
<pre><code>env_file:
- ./common.env
- ./apps/web.env
- /opt/secrets.env
</code></pre><p>环境变量文件中每一行必须符合格式，支持 # 开头的注释行。</p>
<h4 id="common-env-Set-Rails-Rack-environment"><a href="#common-env-Set-Rails-Rack-environment" class="headerlink" title="common.env: Set Rails/Rack environment"></a>common.env: Set Rails/Rack environment</h4><pre><code>RACK_ENV=development
extends
</code></pre><p>基于已有的服务进行扩展。例如我们已经有了一个 webapp 服务，模板文件为 common.yml。</p>
<h4 id="common-yml"><a href="#common-yml" class="headerlink" title="common.yml"></a>common.yml</h4><pre><code>webapp:
build: ./webapp
environment:
  - DEBUG=false
  - SEND_EMAILS=false
</code></pre><p>编写一个新的 development.yml 文件，使用 common.yml 中的 webapp 服务进行扩展。</p>
<h4 id="development-yml"><a href="#development-yml" class="headerlink" title="development.yml"></a>development.yml</h4><p>  web:<br>    extends:<br>      file: common.yml<br>      service: webapp<br>      ports:</p>
<pre><code>- &quot;8000:8000&quot;
links:
- db
environment:
- DEBUG=true
</code></pre><p>  db:<br>      image: postgres<br>后者会自动继承 common.yml 中的 webapp 服务及相关环节变量。</p>
<p>net</p>
<p>设置网络模式。使用和 docker client 的 –net 参数一样的值。</p>
<pre><code>net: &quot;bridge&quot;
net: &quot;none&quot;
net: &quot;container:[name or id]&quot;
net: &quot;host&quot;
pid
</code></pre><p>跟主机系统共享进程命名空间。打开该选项的容器可以相互通过进程 ID 来访问和操作。</p>
<pre><code>pid: &quot;host&quot;
dns
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/15/Dockfile构建镜像/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="八阿哥">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/15/Dockfile构建镜像/" itemprop="url">Dockfile构建镜像</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-10-15T14:36:42+08:00">
                2016-10-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://ppmtv6c75.bkt.clouddn.com/2019/04/08/ed4c7fb136ca5bb23d7c352c943530d9.jpeg" alt="pexels-photo-1563234.jpeg"></p>
<p><a href="&#39;http://blog.csdn.net/we_shell/article/details/38445979&#39;">原文链接</a></p>
<p>Dockfile是一种被Docker程序解释的脚本，Dockerfile由一条一条的指令组成，每条指令对应Linux下面的一条命令。Docker程序将这些Dockerfile指令翻译真正的Linux命令。Dockerfile有自己书写格式和支持的命令，Docker程序解决这些命令间的依赖关系，类似于Makefile。Docker程序将读取Dockerfile，根据指令生成定制的image。相比image这种黑盒子，Dockerfile这种显而易见的脚本更容易被使用者接受，它明确的表明image是怎么产生的。有了Dockerfile，当我们需要定制自己额外的需求时，只需在Dockerfile上添加或者修改指令，重新生成image即可，省去了敲命令的麻烦。</p>
<ol>
<li>Dockerfile的书写规则及指令使用方法</li>
</ol>
<p>Dockerfile的指令是忽略大小写的，建议使用大写，使用 # 作为注释，每一行只支持一条指令，每条指令可以携带多个参数。<br>Dockerfile的指令根据作用可以分为两种，构建指令和设置指令。构建指令用于构建image，其指定的操作不会在运行image的容器上执行；设置指令用于设置image的属性，其指定的操作将在运行image的容器中执行。</p>
<p>（1）FROM（指定基础image）<br>构建指令，必须指定且需要在Dockerfile其他指令的前面。后续的指令都依赖于该指令指定的image。FROM指令指定的基础image可以是官方远程仓库中的，也可以位于本地仓库。<br>该指令有两种格式：</p>
<pre><code>FROM &lt;image&gt;  
</code></pre><p>指定基础image为该image的最后修改的版本。或者：</p>
<p>  FROM <image>:<tag>  </tag></image></p>
<p>指定基础image为该image的一个tag版本。</p>
<p>（2）MAINTAINER（用来指定镜像创建者信息）<br>构建指令，用于将image的制作者相关的信息写入到image中。当我们对该image执行docker inspect命令时，输出中有相应的字段记录该信息。<br>格式：</p>
<pre><code>MAINTAINER &lt;name&gt;  
</code></pre><p>（3）RUN（安装软件用）</p>
<p>  构建指令，RUN可以运行任何被基础image支持的命令。如基础image选择了ubuntu，那么软件管理部分只能使用ubuntu的命令。<br>该指令有两种格式：</p>
<pre><code>RUN &lt;command&gt; (the command is run in a  shell - `/bin/sh -c`)  
RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot; ... ]  (exec form)  
</code></pre><p>（4）CMD（设置container启动时执行的操作）<br>设置指令，用于container启动时指定的操作。该操作可以是执行自定义脚本，也可以是执行系统命令。该指令只能在文件中存在一次，如果有多个，则只执行最后一条。<br>该指令有三种格式：</p>
<pre><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (like an exec, this is the preferred form)  
CMD command param1 param2 (as a shell)  
</code></pre><p>当Dockerfile指定了ENTRYPOINT，那么使用下面的格式：</p>
<pre><code>CMD [&quot;param1&quot;,&quot;param2&quot;] (as default parameters to ENTRYPOINT)  
</code></pre><p>ENTRYPOINT指定的是一个可执行的脚本或者程序的路径，该指定的脚本或者程序将会以param1和param2作为参数执行。所以如果CMD指令使用上面的形式，那么Dockerfile中必须要有配套的ENTRYPOINT。</p>
<p>（5）ENTRYPOINT（设置container启动时执行的操作）<br>设置指令，指定容器启动时执行的命令，可以多次设置，但是只有最后一个有效。<br>两种格式:</p>
<pre><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (like an exec, the preferred form)  
ENTRYPOINT command param1 param2 (as a shell)  
</code></pre><p>该指令的使用分为两种情况，一种是独自使用，另一种和CMD指令配合使用。<br>当独自使用时，如果你还使用了CMD命令且CMD是一个完整的可执行的命令，那么CMD指令和ENTRYPOINT会互相覆盖只有最后一个CMD或者ENTRYPOINT有效。</p>
<p>CMD指令将不会被执行，只有ENTRYPOINT指令被执行  </p>
<pre><code>CMD echo “Hello, World!”  
ENTRYPOINT ls -l  
</code></pre><p>另一种用法和CMD指令配合使用来指定ENTRYPOINT的默认参数，这时CMD指令不是一个完整的可执行命令，仅仅是参数部分；ENTRYPOINT指令只能使用JSON方式指定执行命令，而不能指定参数。</p>
<pre><code>FROM ubuntu  
CMD [&quot;-l&quot;]  
ENTRYPOINT [&quot;/usr/bin/ls&quot;]  
</code></pre><p>（6）USER（设置container容器的用户）<br>设置指令，设置启动容器的用户，默认是root用户。<br>[plain] view plain copy</p>
<p>  指定memcached的运行用户  </p>
<pre><code>ENTRYPOINT [&quot;memcached&quot;]  
USER daemon  
或  
ENTRYPOINT [&quot;memcached&quot;, &quot;-u&quot;, &quot;daemon&quot;]  
</code></pre><p>（7）EXPOSE（指定容器需要映射到宿主机器的端口）<br>设置指令，该指令会将容器中的端口映射成宿主机器中的某个端口。当你需要访问容器的时候，可以不是用容器的IP地址而是使用宿主机器的IP地址和映射后的端口。要完成整个操作需要两个步骤，首先在Dockerfile使用EXPOSE设置需要映射的容器端口，然后在运行容器的时候指定-p选项加上EXPOSE设置的端口，这样EXPOSE设置的端口号会被随机映射成宿主机器中的一个端口号。也可以指定需要映射到宿主机器的那个端口，这时要确保宿主机器上的端口号没有被使用。EXPOSE指令可以一次设置多个端口号，相应的运行容器的时候，可以配套的多次使用-p选项。<br>格式:</p>
<pre><code>EXPOSE &lt;port&gt; [&lt;port&gt;...]  

[plain] view plain copy
# 映射一个端口  
EXPOSE port1  
# 相应的运行容器使用的命令  
docker run -p port1 image  

# 映射多个端口  
EXPOSE port1 port2 port3  
# 相应的运行容器使用的命令  
docker run -p port1 -p port2 -p port3 image  
</code></pre><p>  还可以指定需要映射到宿主机器上的某个端口号<br>    docker run -p host_port1:port1 -p host_port2:port2 -p host_port3:port3 image</p>
<p>端口映射是docker比较重要的一个功能，原因在于我们每次运行容器的时候容器的IP地址不能指定而是在桥接网卡的地址范围内随机生成的。宿主机器的IP地址是固定的，我们可以将容器的端口的映射到宿主机器上的一个端口，免去每次访问容器中的某个服务时都要查看容器的IP的地址。对于一个运行的容器，可以使用docker port加上容器中需要映射的端口和容器的ID来查看该端口号在宿主机器上的映射端口。</p>
<p>（8）ENV（用于设置环境变量）<br>构建指令，在image中设置一个环境变量。<br>格式:</p>
<pre><code>ENV &lt;key&gt; &lt;value&gt;  
</code></pre><p>设置了后，后续的RUN命令都可以使用，container启动后，可以通过docker inspect查看这个环境变量，也可以通过在docker run –env key=value时设置或修改环境变量。<br>假如你安装了JAVA程序，需要设置JAVA_HOME，那么可以在Dockerfile中这样写：</p>
<pre><code>ENV JAVA_HOME /path/to/java/dirent
</code></pre><p>（9）ADD（从src复制文件到container的dest路径）<br>构建指令，所有拷贝到container中的文件和文件夹权限为0755，uid和gid为0；如果是一个目录，那么会将该目录下的所有文件添加到container中，不包括目录；如果文件是可识别的压缩格式，则docker会帮忙解压缩（注意压缩格式）；如果<src>是文件且<dest>中不使用斜杠结束，则会将<dest>视为文件，<src>的内容会写入<dest>；如果<src>是文件且<dest>中使用斜杠结束，则会<src>文件拷贝到<dest>目录下。<br>格式:</dest></src></dest></src></dest></src></dest></dest></src></p>
<pre><code>ADD &lt;src&gt; &lt;dest&gt;  
</code></pre><p><src> 是相对被构建的源目录的相对路径，可以是文件或目录的路径，也可以是一个远程的文件url;</src></p>
<p><dest> 是container中的绝对路径</dest></p>
<p>（10）VOLUME（指定挂载点)）<br>设置指令，使容器中的一个目录具有持久化存储数据的功能，该目录可以被容器本身使用，也可以共享给其他容器使用。我们知道容器使用的是AUFS，这种文件系统不能持久化数据，当容器关闭后，所有的更改都会丢失。当容器中的应用有持久化数据的需求时可以在Dockerfile中使用该指令。<br>格式:</p>
<pre><code>VOLUME [&quot;&lt;mountpoint&gt;&quot;]  
</code></pre><p>  FROM base<br>  VOLUME [“/tmp/data”]<br>运行通过该Dockerfile生成image的容器，/tmp/data目录中的数据在容器关闭后，里面的数据还存在。例如另一个容器也有持久化数据的需求，且想使用上面容器共享的/tmp/data目录，那么可以运行下面的命令启动一个容器：</p>
<pre><code>docker run -t -i -rm -volumes-from  container1 image2 bash  
</code></pre><p>container1为第一个容器的ID，image2为第二个容器运行image的名字。</p>
<p>（11）WORKDIR（切换目录）<br>设置指令，可以多次切换(相当于cd命令)，对RUN,CMD,ENTRYPOINT生效。<br>格式:</p>
<pre><code>WORKDIR /path/to/workdir  
</code></pre><p>  在 /p1/p2 下执行 vim a.txt  </p>
<pre><code>WORKDIR /p1 WORKDIR p2 RUN vim a.txt  
</code></pre><p>（12）ONBUILD（在子镜像中执行）</p>
<p>  ONBUILD <dockerfile关键字><br>  ONBUILD 指定的命令在构建镜像时并不执行，而是在它的子镜像中执行。</dockerfile关键字></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/10/java反射和代理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="八阿哥">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/10/java反射和代理/" itemprop="url">java反射和代理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-10-10T21:01:50+08:00">
                2016-10-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://ppmtv6c75.bkt.clouddn.com/2019/04/08/4348d2e6ab6992f19d2f7062af2d2629.jpeg" alt="pexels-photo-2040612.jpeg"></p>
<p>今天就来谈一谈java的反射和代理</p>
<h3 id="一-反射"><a href="#一-反射" class="headerlink" title="一. 反射"></a>一. 反射</h3><p>在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<p>反射是通过程序化的方式间接对Class进行操作，Class文件有类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象就可以获知Class的结构信息：如构造函数，属性和方法等。我们可以通过这个元信息对象间接调用Class对象的功能。</p>
<p>下面提供一个例子</p>
<pre><code>public class User {


public  String userName;
private String passWord;
private int id;
public void setUserName(String userName){
    this.userName=userName;
}

public String getUserName(){
        return userName;
}


//使用反射创建User类实例
   public static void main(String[] args) {

    User u=new User();//正常创建User类对象
    u.setUserName(&quot;lxh&quot;);
    System.out.println(u.getUserName());
    try {

        //第一种通过实例对象获取构造函数方法
        Constructor con1 = u.getClass().getConstructor();
        User user = (User)con1.newInstance();

        System.out.println(u.getClass().getMethod(&quot;getUserName&quot;).invoke(u,new Object[]{}));
        //u.getClass().getMethod(&quot;setUserName&quot;).invoke(u,&quot;bb&quot;);
                    System.out.println(u.getUserName());

        //第二种通过类加载器加载获取构造函数方法

        ClassLoader load=Thread.currentThread().getContextClassLoader();
        Constructor con2=load.loadClass(&quot;User&quot;).getConstructor();

        Constructor con3=Class.forName(&quot;User&quot;).getConstructor();
        //第三种通过Class类的静态获取构造函数方法
        User user=Class.forName(&quot;User&quot;).getConstror().newInstance();


    }catch(Exception e){
        e.printStackTrace();
    }

}
}
</code></pre><h3 id="二-代理"><a href="#二-代理" class="headerlink" title="二.代理"></a>二.代理</h3><p> 某些情况下，我们无法或者不希望直接对一个对象进行访问时，我们就会用到设计模式中的代理模式(如图)，通常情况下，为了保持行为的一致性，代理类和委托类拥有相同的实现接口,在使用委托类的地方都是可以用代理类来替换；代理类负责预处理消息，并转发消息给委托类、以及对委托类执行完后返回消息的处理；可以这样理解委托类负责过程的具体实现，代理类负责过程实现前后的处理.这样能有效的控制对委托类的直接访问，在设计上获得了更大的灵活性. 可以根据程序运行时，代理类是否存在将代理分为静态代理和动态代理<br> <img src="http://i1.piimg.com/567571/07a33b03c77fa8a6.png" alt=""></p>
<h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>我们直接来看一个例子，我们先定义一个接口service。它的一个实现类Waiter输出“I’ll serve you”，为了让waiter更有礼貌，我们想让他在服务之前先跟客人打招呼“Hello”。</p>
<pre><code>interface service {

    public void doService();
}

class Waiter implements  service{

    public void doService(){
        System.out.println(&quot;I&apos;ll serve you\n&quot;);
    }
}
public class proxyWaiter implements service{

    private Waiter waiter = new Waiter();
    public void doService(){
        System.out.println(&quot;Hello&quot;);
        waiter.doService();
    }
       public static void main(String argsp[]){
           proxyWaiter waiter = new proxyWaiter();
           waiter.doService();
       }

}
</code></pre><p>那么我们现在来看看如果用动态代理该如何呢</p>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><pre><code>import java.lang.reflect.Method;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;

public class proxyHandler implements InvocationHandler{

    private Object object;
    public dymaticProxy(Object object){
        this.object=object;
    }

       public Object invoke(Object proxy,Method     method,Object[]args) throws Throwable{
            System.out.println(&quot;Hello\n&quot;);
                Object obj=method.invoke(object,args);
            return obj;
    }

    public static void main(String []args){
        service waiter= new Waiter();

        proxyHandler handler=new proxyHandler(waiter);

        service newWaiter=         (service)Proxy.newProxyInstance(waiter.getClass().getClassLoader(),waiter.getClass().getInterfaces(),proxy);
        newWaiter.doService();
}
</code></pre><p>}</p>
<p>首先我们实现InvocationHandler，复写invoke方法，然后调用Proxy.newInstance方法返回一个代理对象</p>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><p> 动态代理只能支持接口的代理，这也是因为java的继承性本质所限制的，因为所有的动态代理类都继承了Proxy类，所以再也无法同时继承其他类.然而，我们不可否认动态代理设计的伟大之处，世上所有的事物都不可能完美.<br> 但是如果要实现类的动态代理，可以使用CGlib，它使用动态改变Class字节码文件来实现的，有兴趣的话自己可以查阅相关资料。<br><a href="https://github.com/cglib/cglib" target="_blank" rel="external">相关链接</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/21/Maven入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="八阿哥">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/21/Maven入门/" itemprop="url">Maven入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-09-21T16:24:33+08:00">
                2016-09-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://ppmtv6c75.bkt.clouddn.com/2019/04/08/244d5bf7d2ae2a5b5793b5449101247a.jpeg" alt="pexels-photo-2052251.jpeg"></p>
<h3 id="Maven简单介绍"><a href="#Maven简单介绍" class="headerlink" title="Maven简单介绍"></a>Maven简单介绍</h3><p>它是一个跨平台的异常强大的构建工具，能 够帮我们自动化构建过程，从清理、编译、测试到生成报告，再到打包和部署。我们不需要也不应该一遍又一遍地输入命令，一次又一次地点击鼠标，我们要做的是 使用Maven配置好项目，然后输入简单的命令(如mvn clean install)，Maven会帮我们处理那些烦琐的任务。</p>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>   1.编写POM</p>
<p>   Maven项目的核心是pom.xml。POM（Project Object Model，项目对象模型）定义了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。现在我们先为Hello World项目编写一个最简单的pom.xml。</p>
<pre><code>   &lt;span style=&quot;font-size: small;&quot;&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;  
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-    instance&quot;  
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0  
http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;  
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  
  &lt;groupId&gt;com.example.smartlxh&lt;/groupId&gt;  
  &lt;artifactId&gt;hello-world&lt;/artifactId&gt;  
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  
  &lt;name&gt;Maven Hello World Project&lt;/name&gt;  
&lt;/project&gt;   
&lt;/span&gt;  
</code></pre><p>  2.编写主代码</p>
<pre><code>  package com.example.smartlxh

  public class HelloWorld  
{  
   public String sayHello()  
   {  
     return &quot;Hello Maven&quot;;  
   }  

  public static void main(String[] args)  
   {  
     System.out.print( new HelloWorld().sayHello() );  
    }  
</code></pre><p> 3.编译代码</p>
<p>   在项目根目录下，运行mvn clean compile命令</p>
<p>   得到输出</p>
<pre><code>   [INFO] --------------------------------------------------------------    ----------  
[INFO] Building Maven Hello World Project  
[INFO]    task-segment: [clean, compile]  
[INFO]         ----------------------------------------------------------    --------------  
[INFO] [clean:clean {execution: default-clean}]  
[INFO] Deleting directory D:\code\hello-world\target  
[INFO] [resources:resources {execution: default-    resources}]  
[INFO] skip non existing resourceDirectory D: \code\hello-    world\src\main\resources  
[INFO] [compiler:compile {execution: default-compile}]  
[INFO] Compiling 1 source file to D: \code\hello-world    \target\classes  
[INFO]     ----------------------------------------------------------    --------------  
[INFO] BUILD SUCCESSFUL  
[INFO]     ----------------------------------------------------------    --------------  
[INFO] Total time: 1 second  
[INFO] Finished at: Fri Oct 09 02:08:09 CST 2009  
[INFO] Final Memory: 9M/16M  
[INFO]     ----------------------------------------------------------    --------------  
</code></pre><p>4.编写测试代码</p>
<p>新建目录src/test/java,maven的默认测试代码目录</p>
<p>java中，Junit 是单元测试标准<br>在POM中引入依赖项</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;  
     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  
     xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0  
http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;  
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  
  &lt;groupId&gt;com.juvenxu.mvnbook&lt;/groupId&gt;  
  &lt;artifactId&gt;hello-world&lt;/artifactId&gt;  
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  
  &lt;name&gt;Maven Hello World Project&lt;/name&gt;  
  &lt;dependencies&gt;  
    &lt;dependency&gt;  
   &lt;groupId&gt;junit&lt;/groupId&gt;  
   &lt;artifactId&gt;junit&lt;/artifactId&gt;  
   &lt;version&gt;4.7&lt;/version&gt;  
   &lt;scope&gt;test&lt;/scope&gt;  
&lt;/dependency&gt;  
 &lt;/dependencies&gt;  
&lt;/project&gt;    
</code></pre><p>测试代码为</p>
<pre><code>package com.example.smartlxh

helloworld;  
import static org.junit.Assert.assertEquals;  
import org.junit.Test;  

public class HelloWorldTest  
{  
@Test  
    public void testSayHello()  
    {  
        HelloWorld helloWorld = new HelloWorld();  

        String result = helloWorld.sayHello();  

        assertEquals( &quot;Hello Maven&quot;, result );  
    }  
}   
</code></pre><p>然后运行mvn clean test</p>
<p>控制台输出</p>
<pre><code>[INFO] [compiler:testCompile {execution: default-    testCompile}]  
[INFO] Compiling 1 source file to D: \code\hello-world    \target\test-classes  
[INFO] [surefire:test {execution: default-test}]  
[INFO] Surefire report directory: D:\code\hello-world    \target\surefire-reports  
-------------------------------------------------------  
 T E S T S  
-------------------------------------------------------  
Running com.juvenxu.mvnbook.helloworld.HelloWorldTest  
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time     elapsed: 0.055 sec  
Results :  
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0  
[INFO]     ----------------------------------------------------------    --------------  
[INFO] BUILD SUCCESSFUL  
[INFO]     ----------------------------------------------------------    --------------  
…  
</code></pre><p>5.打包和运行</p>
<p>  执行命令 mvn clean package</p>
<pre><code>  …  
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0  

[INFO] [jar:jar {execution: default-jar}]  
[INFO] Building jar: D:\code\hello-world\target\hello-    world-1.0-SNAPSHOT.jar  
[INFO]   
----------------------------------------------------------    ----------  
[INFO] BUILD SUCCESSFUL  
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/30/Store/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="八阿哥">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/30/Store/" itemprop="url">无法登录到apple Store</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-30T17:02:47+08:00">
                2016-08-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://ppmtv6c75.bkt.clouddn.com/2019/04/08/6cfdde83d280d8e026980ead85b650ec.jpeg" alt="pexels-photo-1115105.jpeg"></p>
<p>这两天不知道为什么无法登录到Itune Store 和Apple Store，一直抱 action can not conplete .<br>google 了一番。<br>几个命令就解决啦。</p>
<pre><code>sudo mkdir -p /Users/Shared
sudo chown root:wheel /Users/Shared
sudo chmod -R 1777 /Users/Shared
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/23/docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="八阿哥">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/23/docker/" itemprop="url">docker</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-23T18:06:19+08:00">
                2016-08-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://ppmtv6c75.bkt.clouddn.com/2019/04/08/5ef9e6b213066b7ee192bddde8ee064a.jpeg" alt="pexels-photo-1366957.jpeg"></p>
<p>最近学习了一下dockr的相关技术，在此作一个总结</p>
<p>一. Docker Engine组成</p>
<pre><code>它由三部分组成，分别是
 1.  server－－一个运行在主机上的守护进程
 2.  REST API －－－提供客户端和server共同的接口
 3. CLI(command line interface)－－－客户端，可以接受用户的指令然后和server通信
</code></pre><p><img src="https://docs.docker.com/engine/article-img/engine-components-flow.png" alt=""></p>
<p>二. 基本名词概念</p>
<pre><code>1. Docker images
 在我理解 images就相当于装系统时的的操作系统镜像。被用来创建Container

2. Docker Containers
    跟目录很相似。包含了一个程序运行所需要的所有组件。
3. Docker registries

    简单理解就是Docker Hub（但是不只是Docker Hub）
</code></pre><p>三.  基本命令</p>
<pre><code>1.docker images（查看host上已有的images）
2.docker rmi 删除images
3.docker ps -a(查看所有container)
如果想要看正在运行的container用命令docker ps
4.docker run cotainerName（创建container） 命令 参数
运行container
5.docker run subcommand 解释

        -t 分配一个container内部的termianl
        －i 和容器交互，通常和－t一起使用
        －d 在后台运行该container
        -P＝－p 5000 映射container端口和host主机端口
        －p 80:5000指定contianer的5000端口映射到host的80端口
6.当在后台运行时，docker logs命令可以看到程序输出
7.docker start，docker stop docker rm
8.docker pull  从Docker Hub上clone images
9.docker push 上传images到Docker Hub上
  首先得docker login登录
  然后使用命令docker tag imageid username／name：tag
</code></pre><p>四.创建images</p>
<p>两种方法</p>
<pre><code>1.docker －t －i 进入命令行，进行你要的修改
然后通过docker commit命令 －m “reason” －a “author”

2.通过Dockerfile（建议）
    创建一个Dockerfile如

    FROM ubuntu:14.04
    MAINTAINER Kate Smith &lt;ksmith@example.com&gt;
    RUN apt-get update &amp;&amp; apt-get install -y ruby ruby-dev
    RUN gem install sinatra

然后使用命令docker build －t username／name：tag
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/15/日计月累/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="八阿哥">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/15/日计月累/" itemprop="url">日计月累</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-15T15:32:39+08:00">
                2016-08-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://ppmtv6c75.bkt.clouddn.com/2019/04/08/e841add1ce3c2db6a176d14275887fdd.jpeg" alt="pexels-photo-1574653.jpeg"></p>
<ol>
<li>memset函数的使用</li>
</ol>
<p>memset(start,value,size)<br>start参数为起始地址，value为初始化的值，size为数组大小，一般用sizeof函数确定</p>
<ol>
<li><p>string.substr(start，length)函数的使用</p>
</li>
<li><p>矩形相交面积的计算</p>
<p> 将矩形用一对点表示（minx，maxx）（maxy，miny）<br> 那么两个矩形rect1{(minx1,miny1)(maxx1, maxy1)}, rect2{(minx2,miny2)(maxx2, maxy2)}</p>
<p> minx = max(minx1, minx2)<br> miny = max(miny1, miny2)<br> maxx = min(maxx1, maxx2)<br> maxy = min(maxy1, maxy2)</p>
<p> 如果两个矩形不相交，那么计算得到的点对坐标必然满足 minx &gt; maxx 或者 miny &gt; maxy</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/14/mongodb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="八阿哥">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/14/mongodb/" itemprop="url">mongodb</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-14T14:56:19+08:00">
                2016-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://ppmtv6c75.bkt.clouddn.com/2019/04/08/a79302438c114c9ae89bc7876365b01f.jpeg" alt="pexels-photo-2058732.jpeg"></p>
<p>今天服务器上的mongodb数据库突然间崩了，同学告诉我，数据插不上去。于是我便ssh到服务器上去查看，起初我查看了一下端口的监听情况，</p>
<pre><code>netstat -nlp | grep 40020
</code></pre><p>（我建的数据库在40020端口），发现确实数据库确实工作在40020端口。然后我又本地连接来测试一下</p>
<pre><code>mongo --port 40020
</code></pre><p>发现本地连接一点问题都没有，增删改查都是可以操作的。这下我一脸懵逼，究竟是什么问题呢。本地可以连接，但是远程却不可以。<br>经过一顿谷歌后终于解决啦问题</p>
<p>只需要几行命令,就OK</p>
<pre><code>sudo iptables -I INPUT -p tcp  --dport 27017 --syn -j ACCEPT
sudo service iptables save
</code></pre><p>那么这时我就好奇了，这几行命令到底是什么意思。iptables命令到底干了什么。<br>接着又是一顿科普</p>
<h3 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h3><p>Iptabels是与Linux内核集成的包过滤防火墙系统，几乎所有的linux发行版本都会包含Iptables的功能。如果 Linux 系统连接到因特网或 LAN、服务器或连接 LAN 和因特网的代理服务器， 则Iptables有利于在 Linux 系统上更好地控制 IP 信息包过滤和防火墙配置。</p>
<p>  netfilter/iptables过滤防火墙系统是一种功能强大的工具，可用于添加、编辑和除去规则，这些规则是在做信息包过滤决定时，防火墙所遵循和组成的规则。这些规则存储在专用的信 息包过滤表中，而这些表集成在 Linux 内核中。在信息包过滤表中，规则被分组放在我们所谓的链（chain）中。</p>
<p>  虽然netfilter/iptables包过滤系统被称为单个实体，但它实际上由两个组件netfilter 和 iptables 组成。</p>
<p>  netfilter 组件也称为内核空间（kernelspace），是内核的一部分，由一些信息包过滤表组成，这些表包含内核用来控制信息包过滤处理的规则集。</p>
<p>  iptables 组件是一种工具，也称为用户空间（userspace），它使插入、修改和除去信息包过滤表中的规则变得容易。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>所以上面的两行命令意思就是<br>在联INPUT上添加一组规则，允许到端口40020的流量</p>
<h6 id="想要详细了解iptables-请参考这篇博客"><a href="#想要详细了解iptables-请参考这篇博客" class="headerlink" title="想要详细了解iptables 请参考这篇博客"></a>想要详细了解iptables 请参考这篇<a href="http://blog.csdn.net/reyleon/article/details/12976341" target="_blank" rel="external">博客</a></h6>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">46</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
